#include "LSTD_types.h"
#include "LBIT_math.h"

#include "TIMER_interface.h"
#include "TIMER_config.h"
#include "TIMER_private.h"
#include "TIMER_registers.h"
void T static void (*TIMER0_pvCallBack)(void) = NULL;
static void (*ICU_pvCallBack)(void) = NULL;

/* TIMER 0 DRIVER */

void TIMER0_voidInit(void)
{
  /*Configure the Waveform mode*/
#if WAVEFORM_MODE == WGM_TIMER_COUNTER_MODE_NORMAL
  CLEAR_BIT(TCCR0, TCCR0_WGM00);
  CLEAR_BIT(TCCR0, TCCR0_WGM01);
#elif WAVEFORM_MODE == WGM_TIMER_COUNTER_MODE_PWM
  SET_BIT(TCCR0, TCCR0_WGM00);
  CLEAR_BIT(TCCR0, TCCR0_WGM01);
#elif WAVEFORM_MODE == WGM_TIMER_COUNTER_MODE_CTC
  CLEAR_BIT(TCCR0, TCCR0_WGM00);
  SET_BIT(TCCR0, TCCR0_WGM01);
#elif WAVEFORM_MODE == WGM_TIMER_COUNTER_MODE_FAST_PWM
  SET_BIT(TCCR0, TCCR0_WGM00);
  SET_BIT(TCCR0, TCCR0_WGM01);
#endif

  /*Configure the compare match output mode*/
  /*0 0 Normal port operation, OC0 disconnected.
  0 1 Toggle OC0 on compare match
  1 0 Clear OC0 on compare match
  1 1 Set OC0 on compare match*/

#if COM_TYPE == COM_NORMAL
  CLEAR_BIT(TCCR0, TCCR0_COM00);
  CLEAR_BIT(TCCR0, TCCR0_COM01);
#elif COM_TYPE == COM_TOGGLE
  SET_BIT(TCCR0, TCCR0_COM00);
  CLEAR_BIT(TCCR0, TCCR0_COM01);
#elif COM_TYPE == COM_CLEAR
  CLEAR_BIT(TCCR0, TCCR0_COM00);
  SET_BIT(TCCR0, TCCR0_COM01);
#elif COM_TYPE == COM_SET
  SET_BIT(TCCR0, TCCR0_COM00);
  SET_BIT(TCCR0, TCCR0_COM01);

  /* 0 0 Normal port operation, OC0 disconnected.
  0 1 Reserved
  1 0 Clear OC0 on compare match, set OC0 at BOTTOM, (nin-inverting mode)
  1 1 Set OC0 on compare match, clear OC0 at BOTTOM,(inverting mode)*/
#elif COM_TYPE == FAST_PWM_NORMAL
  CLEAR_BIT(TCCR0, TCCR0_COM00);
  CLEAR_BIT(TCCR0, TCCR0_COM01);
#elif COM_TYPE == FAST_PWM_RESERVED
  SET_BIT(TCCR0, TCCR0_COM00);
  CLEAR_BIT(TCCR0, TCCR0_COM01);
#elif COM_TYPE == FAST_PWM_CLEAR_ON_COM
  CLEAR_BIT(TCCR0, TCCR0_COM00);
  SET_BIT(TCCR0, TCCR0_COM01);
#elif COM_TYPE == FAST_PWM_SET_ON_COM
  SET_BIT(TCCR0, TCCR0_COM00);
  SET_BIT(TCCR0, TCCR0_COM01);

  /*	 0 0 Normal port operation, OC0 disconnected.
   0 1 Reserved
   1 0 Clear OC0 on compare match when up-counting. Set OC0 on compare match when downcounting.
   1 1 Set OC0 on compare match when up-counting. Clear OC0 on compare match when downcounting*/
#elif COM_TYPE == PHASE_CORRECT_PWM_NORMAL
  CLEAR_BIT(TCCR0, TCCR0_COM00);
  CLEAR_BIT(TCCR0, TCCR0_COM01);
#elif COM_TYPE == PHASE_CORRECT_PWM_RESERVED
  SET_BIT(TCCR0, TCCR0_COM00);
  CLEAR_BIT(TCCR0, TCCR0_COM01);
#elif COM_TYPE == PHASE_CORRECT_PWM_CLEAR_ON_COM
  CLEAR_BIT(TCCR0, TCCR0_COM00);
  SET_BIT(TCCR0, TCCR0_COM01);
#elif COM_TYPE == PHASE_CORRECT_PWM_SET_ON_COM
  SET_BIT(TCCR0, TCCR0_COM00);
  SET_BIT(TCCR0, TCCR0_COM01);
#endif

#if OCIE_STATUS == OCIE_EN
  SET_BIT(TIMSK, TIMSK_OCIE0);
#elif OCIE_STATUS == OCIE_DIS
  CLEAR_BIT(TIMSK, TIMSK_OCIE0);
#endif
#if TOIE_STATUS == TOIE_EN
  SET_BIT(TIMSK, TIMSK_TOIE);
#elif TOIE_STATUS == TOIE_DIS
  CLEAR_BIT(TIMSK, TIMSK_TOIE);
#endif

  /*0 0 0 No clock source (Timer/Counter stopped).
    0 0 1 clkI/O/(No prescaling)
    010 clkI/O/8 (From prescaler)
    011 clkI/O/64 (From prescaler)
    100 clkI/O/256 (From prescaler)
    101 clkI/O/1024 (From prescaler)
    1 1 0 External clock source on T0 pin. Clock on falling edge.
      1 1 1 External clock source on T0 pin. Clock on rising edge
   */
#if CLOCK_SOURCE_PRESCALER == NO_CLOCK_SOURCE
  CLEAR_BIT(TCCR0, TCCR0_CS00);
  CLEAR_BIT(TCCR0, TCCR0_CS01);
  CLEAR_BIT(TCCR0, TCCR0_CS02);

#elif CLOCK_SOURCE_PRESCALER == NO_PRESCALING
  SET_BIT(TCCR0, TCCR0_CS00);
  CLEAR_BIT(TCCR0, TCCR0_CS01);
  CLEAR_BIT(TCCR0, TCCR0_CS02);

#elif CLOCK_SOURCE_PRESCALER == PRESCALING_BY_8
  CLEAR_BIT(TCCR0, TCCR0_CS00);
  SET_BIT(TCCR0, TCCR0_CS01);
  CLEAR_BIT(TCCR0, TCCR0_CS02);

#elif CLOCK_SOURCE_PRESCALER == PRESCALING_BY_64
  SET_BIT(TCCR0, TCCR0_CS00);
  SET_BIT(TCCR0, TCCR0_CS01);
  CLEAR_BIT(TCCR0, TCCR0_CS02);

#elif CLOCK_SOURCE_PRESCALER == PRESCALING_BY_256
  CLEAR_BIT(TCCR0, TCCR0_CS00);
  CLEAR_BIT(TCCR0, TCCR0_CS01);
  SET_BIT(TCCR0, TCCR0_CS02);

#elif CLOCK_SOURCE_PRESCALER == PRESCALING_BY_1024
  SET_BIT(TCCR0, TCCR0_CS00);
  CLEAR_BIT(TCCR0, TCCR0_CS01);
  SET_BIT(TCCR0, TCCR0_CS02);

#elif CLOCK_SOURCE_PRESCALER == PRESCALING_EXT_ON_FALLING
  CLEAR_BIT(TCCR0, TCCR0_CS00);
  SET_BIT(TCCR0, TCCR0_CS01);
  SET_BIT(TCCR0, TCCR0_CS02);
#elif CLOCK_SOURCE_PRESCALER == PRESCALING_EXT_ON_RISING
  SET_BIT(TCCR0, TCCR0_CS00);
  SET_BIT(TCCR0, TCCR0_CS01);
  SET_BIT(TCCR0, TCCR0_CS02);
#endif
}

void TIMER0_voidSetCompareMatchValue(u8 Copy_u8CompareMatchValue)
{
  OCR0 = Copy_u8CompareMatchValue;
}
u8 TIMER0_u8SetCallBack(void (*Copy_PVCallBackFunc)(void))
{
  u8 Local_u8Error = E_OK;
  if (Copy_PVCallBackFunc == E_NULL_POINTER)
  {
    Local_u8Error = E_NULL_POINTER;
  }
  else
  {
    TIMER0_pvCallBack = Copy_PVCallBackFunc;
  }
  return Local_u8Error;
}

/******************************************************************************/
/* TIMER 1 DRIVER */
/******************************************************************************/

void TIMER1_voidInit(void)
{
  /* For Compare Output  Mode Non-PWM */
  /* 0 0 Normal port operation, OC1A/OC1B disconnected.
   0 1 Toggle OC1A/OC1B on compare match
   1 0 Clear OC1A/OC1B on compare match (Set output to low level)
   1 1 Set OC1A/OC1B on compare match (Set output to high level)
   */

#if TIMER1_COMPARE_OUTPUT_MODE_A == NORMAL_OPERATION
  CLEAR_BIT(TCCR1A, TCCR1A_COM1A0);
  CLEAR_BIT(TCCR1A, TCCR1A_COM1A1);

#elif TIMER1_COMPARE_OUTPUT_MODE_A == TOGGLE_ON_COMPARE
  SET_BIT(TCCR1A, TCCR1A_COM1A0);
  CLEAR_BIT(TCCR1A, TCCR1A_COM1A1);

#elif TIMER1_COMPARE_OUTPUT_MODE_A == CLEAR_ON_COMPARE_NO_PWM
  CLEAR_BIT(TCCR1A, TCCR1A_COM1A0);
  SET_BIT(TCCR1A, TCCR1A_COM1A1);

#elif TIMER1_COMPARE_OUTPUT_MODE_A == SET_ON_COMPARE_NO_PWM
  SET_BIT(TCCR1A, TCCR1A_COM1A0);
  SET_BIT(TCCR1A, TCCR1A_COM1A1);

  /* Compare Output Mode, Fast PWM */
  /* 0 0 Normal port operation, OC1A/OC1B disconnected.
   0 1 WGM13:0 = 15: Toggle OC1A on Compare  Match, OC1B disconnected
   (normal port operation).
   For all other WGM13:0 settings, normal port operation, OC1A/OC1B disconnected.
   1 0 Clear OC1A/OC1B on compare match, set OC1A/OC1B at BOTTOM,(non-inverting mode)
   1 1 Set OC1A/OC1B on compare match, clear OC1A/OC1B at BOTTOM, (inverting mode)
   */

#elif TIMER1_COMPARE_OUTPUT_MODE_A == NORMAL_OPERATION
  CLEAR_BIT(TCCR1A, TCCR1A_COM1A0);
  CLEAR_BIT(TCCR1A, TCCR1A_COM1A1);

#elif TIMER1_COMPARE_OUTPUT_MODE_A == TOGGLE_ON_COMPARE
  SET_BIT(TCCR1A, TCCR1A_COM1A0);
  CLEAR_BIT(TCCR1A, TCCR1A_COM1A1);

#elif TIMER1_COMPARE_OUTPUT_MODE_A == CLEAR_ON_COMPARE_SET_ON_TOP
  CLEAR_BIT(TCCR1A, TCCR1A_COM1A0);
  SET_BIT(TCCR1A, TCCR1A_COM1A1);

#elif TIMER1_COMPARE_OUTPUT_MODE_A == SET_ON_COMPARE_CLEAR_ON_TOP
  SET_BIT(TCCR1A, TCCR1A_COM1A0);
  SET_BIT(TCCR1A, TCCR1A_COM1A1);

  /* Compare Output Mode, Phase Correct and Phase and Frequency Correct PWM*/
  /* 0 0 Normal port operation, OC1A/OC1B disconnected.
   0 1 WGM13:0 = 9 or 14: Toggle OC1A on Compare Match, OC1B disconnected (normal port operation).
   For all other WGM13:0 settings, normal port operation, OC1A/OC1B disconnected.
   1 0 Clear OC1A/OC1B on compare match when up-counting. Set OC1A/OC1B on compare match when downcounting.
   1 1 Set OC1A/OC1B on compare match when upcounting. Clear OC1A/OC1B on compare match when downcounting.
   */
#elif TIMER1_COMPARE_OUTPUT_MODE_A == NORMAL_OPERATION
  CLEAR_BIT(TCCR1A, TCCR1A_COM1A0);
  CLEAR_BIT(TCCR1A, TCCR1A_COM1A1);

#elif TIMER1_COMPARE_OUTPUT_MODE_A == TOGGLE_ON_COMPARE
  SET_BIT(TCCR1A, TCCR1A_COM1A0);
  CLEAR_BIT(TCCR1A, TCCR1A_COM1A1);

#elif TIMER1_COMPARE_OUTPUT_MODE_A == CLEAR_ON_COMPARE_UP_SET_ON_COM_DOWN
  CLEAR_BIT(TCCR1A, TCCR1A_COM1A0);
  SET_BIT(TCCR1A, TCCR1A_COM1A1);

#elif TIMER1_COMPARE_OUTPUT_MODE_A == SET_ON_COMPARE_UP_CLEAR_ON_COM_DOWN
  SET_BIT(TCCR1A, TCCR1A_COM1A0);
  SET_BIT(TCCR1A, TCCR1A_COM1A1);

#endif

#if TIMER1_COMPARE_OUTPUT_MODE_B == NORMAL_OPERATION
  CLEAR_BIT(TCCR1A, TCCR1A_COM1B0);
  CLEAR_BIT(TCCR1A, TCCR1A_COM1B1);

#elif TIMER1_COMPARE_OUTPUT_MODE_B == TOGGLE_ON_COMPARE
  SET_BIT(TCCR1A, TCCR1A_COM1B0);
  CLEAR_BIT(TCCR1A, TCCR1A_COM1B1);

#elif TIMER1_COMPARE_OUTPUT_MODE_B == CLEAR_ON_COMPARE_NO_PWM
  CLEAR_BIT(TCCR1A, TCCR1A_COM1B0);
  SET_BIT(TCCR1A, TCCR1A_COM1B1);

#elif TIMER1_COMPARE_OUTPUT_MODE_B == SET_ON_COMPARE_NO_PWM
  SET_BIT(TCCR1A, TCCR1A_COM1B0);
  SET_BIT(TCCR1A, TCCR1A_COM1B1);

#elif TIMER1_COMPARE_OUTPUT_MODE_B == NORMAL_OPERATION
  CLEAR_BIT(TCCR1A, TCCR1A_COM1B0);
  CLEAR_BIT(TCCR1A, TCCR1A_COM1B1);

#elif TIMER1_COMPARE_OUTPUT_MODE_B == TOGGLE_ON_COMPARE
  SET_BIT(TCCR1A, TCCR1A_COM1B0);
  CLEAR_BIT(TCCR1A, TCCR1A_COM1B1);

#elif TIMER1_COMPARE_OUTPUT_MODE_B == CLEAR_ON_COMPARE_SET_ON_TOP
  CLEAR_BIT(TCCR1A, TCCR1A_COM1B0);
  SET_BIT(TCCR1A, TCCR1A_COM1B1);

#elif TIMER1_COMPARE_OUTPUT_MODE_B == SET_ON_COMPARE_CLEAR_ON_TOP
  SET_BIT(TCCR1A, TCCR1A_COM1B0);
  SET_BIT(TCCR1A, TCCR1A_COM1B1);

#elif TIMER1_COMPARE_OUTPUT_MODE_B == NORMAL_OPERATION
  CLEAR_BIT(TCCR1A, TCCR1A_COM1B0);
  CLEAR_BIT(TCCR1A, TCCR1A_COM1B1);

#elif TIMER1_COMPARE_OUTPUT_MODE_B == TOGGLE_ON_COMPARE
  SET_BIT(TCCR1A, TCCR1A_COM1B0);
  CLEAR_BIT(TCCR1A, TCCR1A_COM1B1);

#elif TIMER1_COMPARE_OUTPUT_MODE_B == CLEAR_ON_COMPARE_UP_SET_ON_COM_DOWN
  CLEAR_BIT(TCCR1A, TCCR1A_COM1B0);
  SET_BIT(TCCR1A, TCCR1A_COM1B1);

#elif TIMER1_COMPARE_OUTPUT_MODE_B == SET_ON_COMPARE_UP_CLEAR_ON_COM_DOWN
  SET_BIT(TCCR1A, TCCR1A_COM1B0);
  SET_BIT(TCCR1A, TCCR1A_COM1B1);

#endif

  /*  Waveform Generation Mode */
  /*
0 0 0 0 Normal
0 0 0 1 PWM, Phase Correct, 8-bit
0 0 1 0 PWM, Phase Correct, 9-bit
0 0 1 1 PWM, Phase Correct, 10-bit
0 1 0 0 CTC
0 1 0 1 Fast PWM, 8-bit
0 1 1 0 Fast PWM, 9-bit
0 1 1 1 Fast PWM, 10-bit
1 0 0 0 PWM, Phase and Frequency Correct
1 0 0 1 PWM, Phase and Frequency Correct
1 0 1 0 PWM, Phase Correct
1 0 1 1 PWM, Phase Correct
1 1 0 0 CTC ICR1 Immediate MAX
1 1 0 1 Reserved – – –
1 1 1 0 Fast PWM ICR1 BOTTOM TOP
1 1 1 1 Fast PWM
   */
#if TIMER1_WAVEFORM_GEN_MODE == NORMAL_OPERATION
  CLEAR_BIT(TCCR1A, TCCR1A_WGM10);
  CLEAR_BIT(TCCR1A, TCCR1A_WGM11);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);

#elif TIMER1_WAVEFORM_GEN_MODE == PWM_PHASECOR_8BITS
  SET_BIT(TCCR1A, TCCR1A_WGM10);
  CLEAR_BIT(TCCR1A, TCCR1A_WGM11);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);

#elif TIMER1_WAVEFORM_GEN_MODE == PWM_PHASECOR_9BITS
  CLEAR_BIT(TCCR1A, TCCR1A_WGM10);
  SET_BIT(TCCR1A, TCCR1A_WGM11);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);

#elif TIMER1_WAVEFORM_GEN_MODE == PWM_PHASECOR_10BITS
  SET_BIT(TCCR1A, TCCR1A_WGM10);
  SET_BIT(TCCR1A, TCCR1A_WGM11);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);

#elif TIMER1_WAVEFORM_GEN_MODE == CTC
  CLEAR_BIT(TCCR1A, TCCR1A_WGM10);
  CLEAR_BIT(TCCR1A, TCCR1A_WGM11);
  SET_BIT(TCCR1B, TCCR1B_WGM12);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);

#elif TIMER1_WAVEFORM_GEN_MODE == FAST_PWM_8BITS
  SET_BIT(TCCR1A, TCCR1A_WGM10);
  CLEAR_BIT(TCCR1A, TCCR1A_WGM11);
  SET_BIT(TCCR1B, TCCR1B_WGM12);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);

#elif TIMER1_WAVEFORM_GEN_MODE == FAST_PWM_9BITS
  CLEAR_BIT(TCCR1A, TCCR1A_WGM10);
  SET_BIT(TCCR1A, TCCR1A_WGM11);
  SET_BIT(TCCR1B, TCCR1B_WGM12);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);

#elif TIMER1_WAVEFORM_GEN_MODE == FAST_PWM_10BITS
  SET_BIT(TCCR1A, TCCR1A_WGM10);
  SET_BIT(TCCR1A, TCCR1A_WGM11);
  SET_BIT(TCCR1B, TCCR1B_WGM12);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);

#elif TIMER1_WAVEFORM_GEN_MODE == PWM_PHASE_FREQ_COR_ICR1
  CLEAR_BIT(TCCR1A, TCCR1A_WGM10);
  CLEAR_BIT(TCCR1A, TCCR1A_WGM11);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);
  SET_BIT(TCCR1B, TCCR1B_WGM12);

#elif TIMER1_WAVEFORM_GEN_MODE == PWM_PHASE_FREQ_COR_OCR1A
  SET_BIT(TCCR1A, TCCR1A_WGM10);
  CLEAR_BIT(TCCR1A, TCCR1A_WGM11);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);
  SET_BIT(TCCR1B, TCCR1B_WGM12);

#elif TIMER1_WAVEFORM_GEN_MODE == PWM_PHASE_COR_ICR1
  CLEAR_BIT(TCCR1A, TCCR1A_WGM10);
  SET_BIT(TCCR1A, TCCR1A_WGM11);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);
  SET_BIT(TCCR1B, TCCR1B_WGM12);

#elif TIMER1_WAVEFORM_GEN_MODE == PWM_PHASE_COR_OCR1A
  SET_BIT(TCCR1A, TCCR1A_WGM10);
  SET_BIT(TCCR1A, TCCR1A_WGM11);
  CLEAR_BIT(TCCR1B, TCCR1B_WGM12);
  SET_BIT(TCCR1B, TCCR1B_WGM12);

#elif TIMER1_WAVEFORM_GEN_MODE == CTC_ICR1
  CLEAR_BIT(TCCR1A, TCCR1A_WGM10);
  CLEAR_BIT(TCCR1A, TCCR1A_WGM11);
  SET_BIT(TCCR1B, TCCR1B_WGM12);
  SET_BIT(TCCR1B, TCCR1B_WGM12);

#elif TIMER1_WAVEFORM_GEN_MODE == FAST_PWM_ICR1
  CLEAR_BIT(TCCR1A, TCCR1A_WGM10);
  SET_BIT(TCCR1A, TCCR1A_WGM11);
  SET_BIT(TCCR1B, TCCR1B_WGM12);
  SET_BIT(TCCR1B, TCCR1B_WGM12);

#elif TIMER1_WAVEFORM_GEN_MODE == FAST_PWM_OCR1A
  SET_BIT(TCCR1A, TCCR1A_WGM10);
  SET_BIT(TCCR1A, TCCR1A_WGM11);
  SET_BIT(TCCR1B, TCCR1B_WGM12);
  SET_BIT(TCCR1B, TCCR1B_WGM12);

#endif
  /* 0 0 0 No clock source (Timer/Counter stopped).
   0 0 1 clkI/O/(No prescaling)
   0 1 0 clkI/O/8 (From prescaler)
   0 1 1 clkI/O/64 (From prescaler)
   1 0 0 clkI/O/256 (From prescaler)
   1 0 1 clkI/O/1024 (From prescaler)
   1 1 0 External clock source on T0 pin. Clock on falling edge.
   1 1 1 External clock source on T0 pin. Clock on rising edge
   */
#if TIMER1_CLOCK_SOURCE_PRESCALER == NO_CLOCK_SOURCE
  CLEAR_BIT(TCCR1B, TCCR1B_CS10);
  CLEAR_BIT(TCCR1B, TCCR1B_CS11);
  CLEAR_BIT(TCCR1B, TCCR1B_CS12);

#elif TIMER1_CLOCK_SOURCE_PRESCALER == NO_PRESCALING
  SET_BIT(TCCR1B, TCCR1B_CS10);
  CLEAR_BIT(TCCR1B, TCCR1B_CS11);
  CLEAR_BIT(TCCR1B, TCCR1B_CS12);

#elif TIMER1_CLOCK_SOURCE_PRESCALER == PRESCALING_BY_8
  CLEAR_BIT(TCCR1B, TCCR1B_CS10);
  SET_BIT(TCCR1B, TCCR1B_CS11);
  CLEAR_BIT(TCCR1B, TCCR1B_CS12);

#elif TIMER1_CLOCK_SOURCE_PRESCALER == PRESCALING_BY_64
  SET_BIT(TCCR1B, TCCR1B_CS10);
  SET_BIT(TCCR1B, TCCR1B_CS11);
  CLEAR_BIT(TCCR1B, TCCR1B_CS12);

#elif TIMER1_CLOCK_SOURCE_PRESCALER == PRESCALING_BY_256
  CLEAR_BIT(TCCR1B, TCCR1B_CS10);
  CLEAR_BIT(TCCR1B, TCCR1B_CS11);
  SET_BIT(TCCR1B, TCCR1B_CS12);

#elif TIMER1_CLOCK_SOURCE_PRESCALER == PRESCALING_BY_1024
  SET_BIT(TCCR1B, TCCR1B_CS10);
  CLEAR_BIT(TCCR1B, TCCR1B_CS11);
  SET_BIT(TCCR1B, TCCR1B_CS12);

#elif TIMER1_CLOCK_SOURCE_PRESCALER == PRESCALING_EXT_ON_FALLING
  CLEAR_BIT(TCCR1B, TCCR1B_CS10);
  SET_BIT(TCCR1B, TCCR1B_CS11);
  SET_BIT(TCCR1B, TCCR1B_CS12);

#elif TIMER1_CLOCK_SOURCE_PRESCALER == PRESCALING_EXT_ON_RISING
  SET_BIT(TCCR1B, TCCR1B_CS10);
  SET_BIT(TCCR1B, TCCR1B_CS11);
  SET_BIT(TCCR1B, TCCR1B_CS12);
#endif

#if OCIE1A_STATUS == OCIE1A_ENABLE
  SET_BIT(TIMSK, TIMSK_OCIE1A);
#elif OCIE1A_STATUS == OC1E1A_DISABLE
  CLEAR_BIT(TIMSK, TIMSK_OCIE1A);
#endif

#if OCIE1B_STATUS == OCIE1B_ENABLE
  SET_BIT(TIMSK, TIMSK_OCIE1B);

#elif OCIE1B_STATUS == OCIE1B_DISABLE
  CLEAR_BIT(TIMSK, TIMSK_OCIE1B);
#endif

#if TOIE1_STATUS == TOIE1_ENABLE
  SET_BIT(TIMSK, TIMSK_TOIE1);

#elif OCIE1B_STATUS == OCIE1B_DISABLE
  CLEAR_BIT(TIMSK, TIMSK_TOIE1);
#endif
}

void TIMER1_voidSetICR(u16 Copy_u16Top)
{
  ICR1 = Copy_u16Top;
}
void TIMER1_voidSetTIMER1CHANNEL1CompareMatchValue(u16 Copy_u8CompareMatchValue)
{
  OCR1A = Copy_u8CompareMatchValue;
}

void TIMER1_voidSetTimer1Value(u16 Copy_u16Value)
{
  TCNT1 = Copy_u16Value;
}

u16 TIMER1_voidGetTimer1Value(void)
{
  return TCNT1;
}

/******************************************************************************/
/* ICU DRIVER */
/******************************************************************************/

void ICU_voidInit(void)
{
  /* Set the noise canceller */
#if INPUT_CAPTURE_NOISE_CANCELER_STATUS == INPUT_CAPTURE_NOISE_CANCELER_ENABLE
  SET_BIT(TCCR1B, TCCR1B_ICNC1);
#elif INPUT_CAPTURE_NOISE_CANCELER_STATUS == INPUT_CAPTURE_NOISE_CANCELER_DISABLE
  CLEAR_BIT(TCCR1B, TCCR1B_ICNC1);
#endif

#if INPUT_CAPTURE_EDGE_SELECT == ICU_RISING_EDGE
  SET_BIT(TCCR1B, TCCR1B_ICES1);
#elif INPUT_CAPTURE_EDGE_SELECT == ICU_FALLING_EDGE
  CLEAR_BIT(TCCR1B, TCCR1B_ICES1);
#endif

#if TICIE1_STATUS == TICIE1_ENABLE
  SET_BIT(TIMSK, TIMSK_TICIE1);

#elif TICIE1_STATUS == TICIE1_DISABLE
  CLEAR_BIT(TIMSK, TIMSK_TICIE1);
#endif
}

void ICU_voidSetTriggerEdge(u8 Copy_u8Edge)
{
  switch (Copy_u8Edge)
  {
  case ICU_RISING_EDGE:
    SET_BIT(TCCR1B, TCCR1B_ICES1);
    break;
  case ICU_FALLING_EDGE:
    CLEAR_BIT(TCCR1B, TCCR1B_ICES1);

    break;

  default: /*Do nothing */
    break;
  }
}

void ICU_voidInterruptEnable(void)
{
  SET_BIT(TIMSK, TIMSK_TICIE1);
}

void ICU_voidInterruptDisable(void)
{
  CLEAR_BIT(TIMSK, TIMSK_TICIE1);
}

u8 ICU_u8SetCallBack(void (*Copy_PVCallBackFunc)(void))
{
  ICU_pvCallBack = Copy_PVCallBackFunc;
}

u16 ICU_u16ICUReadValue()
{
  return ICR1;
}

/* To do specify the interrupt source*/

void __vector_10(void) __attribute__((signal));
void __vector_10(void)
{
  if (TIMER0_pvCallBack != NULL)
  {
    TIMER0_pvCallBack();
  }
}

void __vector_6(void) __attribute__((signal));
void __vector_6(void)
{
  if (ICU_pvCallBack != NULL)
  {
    ICU_pvCallBack();
  }
}
